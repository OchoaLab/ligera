% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ligera_multi.R
\name{ligera_multi}
\alias{ligera_multi}
\title{LIGERA_multi: LIght GEnetic Robust Association multiscan function}
\usage{
ligera_multi(
  X,
  trait,
  kinship,
  q_cut = 0.05,
  one_per_iter = FALSE,
  kinship_inv = NULL,
  covar = NULL,
  loci_on_cols = FALSE,
  mem_factor = 0.7,
  mem_lim = NA,
  tol = 1e-15,
  maxIter = 1e+06
)
}
\arguments{
\item{X}{The \code{m}-by-\code{n} genotype matrix, containing dosage values in (0, 1, 2, NA) for the reference allele at each locus.}

\item{trait}{The length-\code{n} trait vector, which may be real valued and contain missing values.}

\item{kinship}{The \code{n}-by-\code{n} kinship matrix, estimated by other methods (i.e. the \code{popkin} package).}

\item{q_cut}{The q-value threshold to admit new loci into the polygenic model.}

\item{one_per_iter}{If true, only the most significant locus per iteration is added to model of next iteration.  Otherwise all significant loci per iteration are added to the model of next iteration.}

\item{kinship_inv}{The optional matrix inverse of the kinship matrix.  Setting this parameter is not recommended, as internally a conjugate gradient method (\verb{\link[cPCG]\{cgsolve\}}) is used to implicitly invert this matrix, which is much faster.  However, for very large numbers of traits without missingness and the same kinship matrix, inverting once might be faster.}

\item{covar}{An optional \code{n}-by-\code{K} matrix of \code{K} covariates, aligned with the individuals.}

\item{loci_on_cols}{If \code{TRUE}, \code{X} has loci on columns and individuals on rows; if false (the default), loci are on rows and individuals on columns.
If \code{X} is a BEDMatrix object, \code{loci_on_cols = TRUE} is set automatically.}

\item{mem_factor}{Proportion of available memory to use loading and processing genotypes.
Ignored if \code{mem_lim} is not \code{NA}.}

\item{mem_lim}{Memory limit in GB, used to break up genotype data into chunks for very large datasets.
Note memory usage is somewhat underestimated and is not controlled strictly.
Default in Linux and Windows is \code{mem_factor} times the free system memory, otherwise it is 1GB (OSX and other systems).}

\item{tol}{Tolerance value passed to \verb{\link[cPCG]\{cgsolve\}}.}

\item{maxIter}{Maximum number of iterations passed to \verb{\link[cPCG]\{cgsolve\}}.}
}
\value{
A tibble containing the following association statistics from the last scan for non-selected loci.
For selected loci, these are the values from the scan before each was added to the model (as after addition they get \verb{beta ~= 0} and \verb{pval ~= 1}).
\itemize{
\item \code{pval}: The p-value of the last association scan.
\item \code{beta}: The estimated effect size coefficient for the trait vector at this locus.
\item \code{beta_std_dev}: The estimated coefficient variance of this locus (varies due to dependence on minor allele frequency).
\item \code{p_q}: The allele variance estimate (estimate of \code{p*(1-p)}).  The number of heterozygotes, weighted by inbreeding coefficient, and with pseudocounts included, is used in this estimate (in other words, it does not equal MAF * ( 1 - MAF ), where MAF is the marginal allele frequency.
\item \code{t_stat}: The test statistic, equal to \code{beta / beta_std_dev}.
\item \code{qval}: The q-value of the last association scan.
\item \code{sel}: the order in which loci were selected, or zero if they were not selected.
}
}
\description{
This function performs multiple genetic association scans, adding one significant locus per iteration to the model (modeled as a covariate) to increase power in the final model.
The function returns a tibble containing association statistics and several intermediates.
}
\details{
Suppose there are \code{n} individuals and \code{m} loci.
}
\examples{
# Construct random data
# number of individuals we want
n_ind <- 5
# number of loci we want
m_loci <- 100
# a not so small random genotype matrix
X <- matrix(
    rbinom( m_loci * n_ind, 2, 0.5 ),
    nrow = m_loci
)
# random trait
trait <- rnorm( n_ind )
# add a genetic effect from first locus
trait <- trait + X[ 1, ]
# kinship matrix
kinship <- diag( n_ind ) / 2 # unstructured case

tib <- ligera_multi( X, trait, kinship )
tib

}
\seealso{
The \code{popkin} and \code{cPCG} packages.
}
